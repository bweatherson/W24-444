---
subtitle: "444 Lecture 16"
title: "Backward Induction"
author: "Brian Weatherson"
date: "March 14 2024"
format:
  revealjs:
    theme:
      - default
      - robot-lung.scss
    margin: 0.15
    center: false
    self-contained: true
    slide-number: c/t
    show-slide-number: all
keep-md: false
tbl-cap-location: bottom
code-block-background: true
---

# Trees

## Time

- The tables we discussed last week represent games where each player moves once, and those moves are simultaneous.
- But few games are like that.
- We need a way to represent games that take time.

## Trees

- We do that with trees.
- A tree represents all the ways that a game that takes place over time could go.

## Nodes

> - Trees have nodes.
> - Some nodes are **terminal nodes**; they represent that the game has ended.
> - Each terminal node has a payout for each of the players.
> - At any other node, either a player moves, or Nature 'moves'.
> - One of the non-terminal nodes is special: it is the node where the game starts.

## Branches

- Each non-terminal node has branches, leading to other nodes.
- A move at a node is always a choice of branches.

## {.plain}

::: {.columns}

:::: {.column width="45%"}
![Example from Bonanno](images/3_1a.png){height=80%}
::::

:::: {.column width="50%"}
- There are two players, 1 and 2.
- Each player moves once.
- First 1 moves, then 2 moves, then the game ends.
::::

:::

## {.plain}

::: {.columns}

:::: {.column width="45%"}
![Example from Bonanno](images/3_1a.png){height=80%}
::::

:::: {.column width="50%"}
- Some books use a special notation for the initial node, such as having an open circle rather than a closed circle.
- Bonanno doesn't, but it's clear in context what the initial node is.
::::

:::

## {.plain}

::: {.columns}

:::: {.column width="45%"}
![Example from Bonanno](images/3_1a.png){height=80%}
::::

:::: {.column width="50%"}

- As he goes on to note, this isn't really a tree yet.
- It describes the physical outcomes of the game at each terminal node, but not the **payoffs**.

::::

:::

## {.plain}

::: {.columns}

:::: {.column width="45%"}
![Example from Bonanno](images/3_1a.png){height=80%}
::::

:::: {.column width="50%"}
There is a natural function from outcomes to payoffs - more money equals more utility - but it is not a compulsory interpretation.
::::

:::

## Future Additions

> - Moves by Nature
> - Moves under uncertainty

# Backward Induction

## Class of Games We're Discussing

> - Two-player
> - Turn-taking
> - Finite
> - No hidden facts
> - No randomness
> - We'll start with zero-sum games, though drop this later.

## Five

- There are two players, who we'll call A and B.
- First A moves, then B, then finally A moves again. 
- Each move involves announcing a number, 1 or 2. 
- A wins if after the three moves, the numbers announced sum to 5. 
- B wins otherwise. 

## Five

Question: How should you play this game?

## Game Tree for Five {.fragile}
```{r engine="tikz"}
#| fig-format: png
#| echo: false


\usetikzlibrary{calc}

\begin{tikzpicture}
  \tikzset{
    % Three node styles for game trees: solid and hollow and square
      solid node/.style={circle,draw,inner sep=1.5,fill=black},
      hollow node/.style={circle,draw,inner sep=1.5},
      square node/.style={rectangle,draw, inner sep = 1, fill = black}
      }

  % Specify spacing for each level of the tree
  \tikzstyle{level 1}=[level distance=15mm,sibling distance=40mm]
  \tikzstyle{level 2}=[level distance=15mm,sibling distance=20mm]
  \tikzstyle{level 3}=[level distance=15mm,sibling distance=10mm]

  \node[hollow node,label=above:{A}]{}
    child { node [solid node,label=left:{B}] {}
      child { node [solid node,label=left:{A}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$L$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[left]{1}
        }
      child { node [solid node,label=right:{A}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[right]{2}
        }        
      edge from parent
        node[left]{1}
    }
    child { node [solid node,label=right:{B}] {}
      child { node [solid node,label=left:{A}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[left]{1}
        }
      child { node [solid node,label=right:{A}] {}
        child { node [] {$W$}
            edge from parent
            node[left]{1}}
        child { node [] {$L$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[right]{2}
        }        
      edge from parent
        node[right]{2}
    }
    
    ;
    \end{tikzpicture}
```


$W$ means that A wins, and $L$ means that B wins.

## Solving These Games

- Work backwards.
- First, find points where a player has a choice between two terminal nodes.
- Assume that they will make the higher value for them choice.
- Mark that choice, e.g., by doubling the line (as the textbook does).
- If there are ties, mark both of the lines. (This gets more complicated once we leave zero-sum games.)

## Solving These Games

- Assign the value they choose to the choice node.
- So just the game assigns values to terminal nodes, we'll now assign value to choice nodes.
- In **Five**, we'll assign the value $W$ to the bottom right node.

## Five (after one step)

```{r engine="tikz"}
#| fig-format: png
#| echo: false


\usetikzlibrary{calc}

\begin{tikzpicture}
  \tikzset{
    % Three node styles for game trees: solid and hollow and square
      solid node/.style={circle,draw,inner sep=1.5,fill=black},
      hollow node/.style={circle,draw,inner sep=1.5},
      square node/.style={rectangle,draw, inner sep = 1, fill = black}
      }

  % Specify spacing for each level of the tree
  \tikzstyle{level 1}=[level distance=15mm,sibling distance=40mm]
  \tikzstyle{level 2}=[level distance=15mm,sibling distance=20mm]
  \tikzstyle{level 3}=[level distance=15mm,sibling distance=10mm]

  \node[hollow node,label=above:{A}]{}
    child { node [solid node,label=left:{B}] {}
      child { node [solid node,label=left:{A}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$L$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[left]{1}
        }
      child { node [solid node,label=right:{A}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[right]{2}
        }        
      edge from parent
        node[left]{1}
    }
    child { node [solid node,label=right:{B}] {}
      child { node [solid node,label=left:{A}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[left]{1}
        }
      child { node [solid node,label=right:{$W$}] {}
        child { node [] {$W$}
            edge from parent [double]
            node[left]{1}}
        child { node [] {$L$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[right]{2}
        }        
      edge from parent
        node[right]{2}
    }
    
    ;
    \end{tikzpicture}
```

## Five (after first level)

On the next slide I'll do the same thing for the other three nodes where A ends the game.

- Note that for one of them, I'll double **two** lines, because we can't figure out just by backward induction reasoning what will happen.

---

```{r engine="tikz"}
#| fig-format: png
#| echo: false


\usetikzlibrary{calc}

\begin{tikzpicture}
  \tikzset{
    % Three node styles for game trees: solid and hollow and square
      solid node/.style={circle,draw,inner sep=1.5,fill=black},
      hollow node/.style={circle,draw,inner sep=1.5},
      square node/.style={rectangle,draw, inner sep = 1, fill = black}
      }

  % Specify spacing for each level of the tree
  \tikzstyle{level 1}=[level distance=15mm,sibling distance=40mm]
  \tikzstyle{level 2}=[level distance=15mm,sibling distance=20mm]
  \tikzstyle{level 3}=[level distance=15mm,sibling distance=10mm]

  \node[hollow node,label=above:{A}]{}
    child { node [solid node,label=left:{B}] {}
      child { node [solid node,label=left:{$L$}] {}
        child { node [] {$L$}
            edge from parent [double]
            node[left]{1}}
        child { node [] {$L$}
            edge from parent [double]
            node[right]{2}}
        edge from parent
            node[left]{1}
        }
      child { node [solid node,label=right:{$W$}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent [double]
            node[right]{2}}
        edge from parent
            node[right]{2}
        }        
      edge from parent
        node[left]{1}
    }
    child { node [solid node,label=right:{B}] {}
      child { node [solid node,label=left:{$W$}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent [double]
            node[right]{2}}
        edge from parent
            node[left]{1}
        }
      child { node [solid node,label=right:{$W$}] {}
        child { node [] {$W$}
            edge from parent [double]
            node[left]{1}}
        child { node [] {$L$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[right]{2}
        }        
      edge from parent
        node[right]{2}
    }
    
    ;
    \end{tikzpicture}
```

## Next Steps Back

- Now we do the same thing for B.
- We act as if B is choosing between terminal nodes.
- It is as if A doesn't have a choice - they will just make the choice that is best for them (i.e., worst for B).
- So B knows what the outcome of each choice will be.
- Remember, B prefers $L$ to $W$, because $L$ means that A loses and so B wins.

---

```{r engine="tikz"}
#| fig-format: png
#| echo: false


\usetikzlibrary{calc}

\begin{tikzpicture}
  \tikzset{
    % Three node styles for game trees: solid and hollow and square
      solid node/.style={circle,draw,inner sep=1.5,fill=black},
      hollow node/.style={circle,draw,inner sep=1.5},
      square node/.style={rectangle,draw, inner sep = 1, fill = black}
      }

  % Specify spacing for each level of the tree
  \tikzstyle{level 1}=[level distance=15mm,sibling distance=40mm]
  \tikzstyle{level 2}=[level distance=15mm,sibling distance=20mm]
  \tikzstyle{level 3}=[level distance=15mm,sibling distance=10mm]

  \node[hollow node,label=above:{A}]{}
    child { node [solid node,label=left:{$L$}] {}
      child { node [solid node,label=left:{$L$}] {}
        child { node [] {$L$}
            edge from parent [double]
            node[left]{1}}
        child { node [] {$L$}
            edge from parent [double]
            node[right]{2}}
        edge from parent [double]
            node[left]{1}
        }
      child { node [solid node,label=right:{$W$}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent [double]
            node[right]{2}}
        edge from parent
            node[right]{2}
        }        
      edge from parent
        node[left]{1}
    }
    child { node [solid node,label=right:{$W$}] {}
      child { node [solid node,label=left:{$W$}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent [double]
            node[right]{2}}
        edge from parent [double]
            node[left]{1}
        }
      child { node [solid node,label=right:{$W$}] {}
        child { node [] {$W$}
            edge from parent [double]
            node[left]{1}}
        child { node [] {$L$}
            edge from parent
            node[right]{2}}
        edge from parent [double]
            node[right]{2}
        }        
      edge from parent
        node[right]{2}
    }
    
    ;
    \end{tikzpicture}
```

## Five (After Two Rounds)

- So we act as if getting to the left hand node means B wins, and getting to the right hand node means A wins.
- And now we just have to make the choice for the initial node, using this fact.

## Five (Full Graph)

```{r engine="tikz"}
#| fig-format: png
#| echo: false


\usetikzlibrary{calc}

\begin{tikzpicture}
  \tikzset{
    % Three node styles for game trees: solid and hollow and square
      solid node/.style={circle,draw,inner sep=1.5,fill=black},
      hollow node/.style={circle,draw,inner sep=1.5},
      square node/.style={rectangle,draw, inner sep = 1, fill = black}
      }

  % Specify spacing for each level of the tree
  \tikzstyle{level 1}=[level distance=15mm,sibling distance=40mm]
  \tikzstyle{level 2}=[level distance=15mm,sibling distance=20mm]
  \tikzstyle{level 3}=[level distance=15mm,sibling distance=10mm]

  \node[hollow node,label=above:{$W$}]{}
    child { node [solid node,label=left:{$L$}] {}
      child { node [solid node,label=left:{$L$}] {}
        child { node [] {$L$}
            edge from parent [double]
            node[left]{1}}
        child { node [] {$L$}
            edge from parent [double]
            node[right]{2}}
        edge from parent [double]
            node[left]{1}
        }
      child { node [solid node,label=right:{$W$}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent [double]
            node[right]{2}}
        edge from parent
            node[right]{2}
        }        
      edge from parent
        node[left]{1}
    }
    child { node [solid node,label=right:{$W$}] {}
      child { node [solid node,label=left:{$W$}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent [double]
            node[right]{2}}
        edge from parent [double]
            node[left]{1}
        }
      child { node [solid node,label=right:{$W$}] {}
        child { node [] {$W$}
            edge from parent [double]
            node[left]{1}}
        child { node [] {$L$}
            edge from parent
            node[right]{2}}
        edge from parent [double]
            node[right]{2}
        }        
      edge from parent [double]
        node[right]{2}
    }
    
    ;
    \end{tikzpicture}
```

## Five - Full Analysis

- The equilibrium state of the game is that A wins.
- A plays 2 first.
- Then B can play anything they line.
- But whatever they do, A will win, by playing the opposite number.

## Backwards Induction

- This process is called backwards induction.
- We start at the possible ends of the game.
- At each step, we assume that each player makes the best decision they can, on the assumption that later players will do the same thing.

# Chain Store Paradox

## Chain Store Paradox

The Wikipedia page on this isn't bad, and the original article is somewhat accessible.

- [The Chain Store Paradox](https://link.springer.com/article/10.1007/BF00131770), by Reinhard Selten, _Theory and Decision_ volume 9, 1978.

## Chain Store Paradox

- Imagine in 20 college towns, Starbucks is the only coffee shop in town.
- In each of the towns, some local business people are thinking of starting a new coffee shop.
- Each of them will soon face a critical decision, whether to go ahead with the shop or give up because it's too hard.

## Payouts

In each town, there are four options:

- The local person can enter (E) or stay out (S).
- If they enter, Starbucks can do nothing (N) or cut prices (C). (Note this happens second.)

Here is the payoff table per town.

|    |   E   |   S   |
|:--:|:-----:|:-----:|
| N  |   2,2 |  1,5  |
| C  |  0,0  |  1,5  |

## Payouts

|    |   E   |   S   |
|:--:|:-----:|:-----:|
| N  |   2,2 |  1,5  |
| C  |  0,0  |  1,5  |

In each town, the only equilibrium of the game is that the local enters, and Starbucks does nothing.

## Chain Store

What about the following reasoning for Starbucks?

- In the first town, if local enters, we'll get 0 rather than 2 by starting a price war.
- That's a cost, but it's nothing compared to the deterrence effect.
- Sending a message to the other 19 that they're better off staying out will be worth losing some money in town 1.

## Threat

|    |   E   |   S   |
|:--:|:-----:|:-----:|
| N  |   2,2 |  1,5  |
| C  |  0,0  |  1,5  |

Note that for subsequent towns, the local has a choice between getting 1, if they stay out, or 0, if they enter, assuming Starbucks will launch a price war.

## Threats

This might not be particularly *nice* of Starbucks, and maybe in some places it would even be illegal. (Though really, who is going to start a lawsuit against Starbucks cutting prices?)

But this sure looks like sensible reasoning on Starbucks's part.

Take a small loss now to preserve the value of monopoly privileges in the future.

## Backward Induction

The problem is that there's this argument that it shouldn't work.

- In town 20, there is no deterrence benefit from cutting prices.
- So Starbucks won't cut prices there, and the fact that they did in the past won't deter the locals in town 20.

## Backward Induction

Now think about the locals in town 19. Should they fear that Starbucks will launch a price war to deter future owners?

- No; it would only deter the locals in town 20, and we just showed they shouldn't ever be deterred.
- So the locals in town 19 shouldn't be deterred.

. . .

And that holds in 18, in 17, and all the way back to the start.

## What Went Wrong

Backward induction reasoning requires a *very* strong rationality assumption.

- It requires not just that everyone is rational, but that everyone knows everyone is rational, everyone knows that everyone knows that everyone is rational, and so on.
- And this is not what we find in the real world.

## An Experiment

- You'll play the following game. I'm hoping you'll play it three times with three different people, though at the mercy of the tech a little here.
- At the start of the game there is $0.20 in a pot.
- At each round, a player can end or continue. (This game is not symmetric; someone goes first.)
- If the game ends, the pot is divided **unevenly**. The person who ended the game gets $0.20 more.
- So if it ends with \$1 in the pot, the ender gets \$0.60, and the other player gets \$0.40.

## An Experiment

- If the game does not end, $0.20 gets added to the pot.
- Once the pot reaches \$2, the game ends, and player 2 gets \$1.10, while player 1 gets \$0.90.

## Theory

- The backward induction solution to the game is that player 1 ends on the first move.
- At the second last move, player 1 can end and get \$1, or continue and get \$0.90.
- At the third last move, player 2 can end and get \$0.90, or continue, and, if player 1 ends the next move, get \$0.80.
- And so on, until player 1 ends on the very first move.
- Let's see if that happens in practice.

## Experiment

- https://veconlab.econ.virginia.edu/login.php
- Experiment name: **pbw4**
- This is last slide; but hopefully we'll have time to talk about what happened.
