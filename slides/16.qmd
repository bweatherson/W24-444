---
subtitle: "444 Lecture 16"
title: "Backward Induction"
author: "Brian Weatherson"
date: "March 14 2024"
format:
  revealjs:
    theme:
      - default
      - robot-lung.scss
    margin: 0.15
    center: false
    self-contained: true
    slide-number: c/t
    show-slide-number: all
keep-md: false
tbl-cap-location: bottom
code-block-background: true
---

# Traveller's Dilemma

## Traveller's Dilemma

I messed this up last time, so I'm trying again.

Here are the actual instructions.

---

- It's a 2 player game.
- You will play 5 times, hopefully with different people. (I want to see what happens over time, but not in an Axelrod style repeated game.)
- Each of you will make a 'bid' between $1 and $2. It must be a multiple of $0.1, so the bids are $1.00, $1.10, $1.20, ..., $1.90, $2.
- If the bids are tied, you each get that amount.
- If one person bids lower, they get what they bid plus $0.20. (I messed this up when I was resetting the game last time.)
- Also if one person bids lower, the other gets the low bid **minus** $0.20.

## Example Games

A bids $1.80, B bids $1.80
:    They both get $1.80.

A bids $1.80, B bids $1.70
:    A gets $1.50, B gets $1.90.

A bids $1.90, B bids $1.80
:    A gets $1.60, B gets $2.00.

- Most you can get is $2.10, if you bid $1.90, other bids $2.
- Least you can get is $0.90, if you bid $1.10, other bids $1.

## Playtime

Site: veconlab.econ.virginia.edu/login.php

Code: **pbw3**. 

(Same code as tried on Tuesday, I reset parameters.)

## Discussion

Let's see what happens. I'm looking for two things

1. Do we immediately go to the result that we get from deleting weakly dominated strategies?
2. Do we go there over time?

## Theory

Both $1.80 and $1.90 **weakly** dominate $2.

- $1.90 does better if the other plays $2.
- $1.80 does better if the other plays $1.90.
- Otherwise they do the **same**.

If we eliminate $2, then $1.70 and $1.80 both weakly dominate $1.90.

- $1.70 does worse than $2 if the other person plays $2, but once $2 is eliminated, there is no way for $2 to do better.

## Theory

And this process can continue all the way down to $1 as the only remaining solution.

- Note this requires iterated deletion of **weakly** dominated strategies.
- Note also that it doesn't always match up with practice.

# Trees

## Time

- The tables we discussed last week represent games where each player moves once, and those moves are simultaneous.
- But few games are like that.
- We need a way to represent games that take time.

## Trees

- We do that with trees.
- A tree represents all the ways that a game that takes place over time could go.

## Nodes

> - Trees have nodes.
> - Some nodes are **terminal nodes**; they represent that the game has ended.
> - Each terminal node has a payout for each of the players.
> - At any other node, either a player moves, or Nature 'moves'.
> - One of the non-terminal nodes is special: it is the node where the game starts.

## Branches

- Each non-terminal node has branches, leading to other nodes.
- A move at a node is always a choice of branches.

## {.plain}

::: {.columns}

:::: {.column width="45%"}
![Example from Bonanno](images/3_1a.png){height=80%}
::::

:::: {.column width="50%"}
- There are two players, 1 and 2.
- Each player moves once.
- First 1 moves, then 2 moves, then the game ends.
::::

:::

## {.plain}

::: {.columns}

:::: {.column width="45%"}
![Example from Bonanno](images/3_1a.png){height=80%}
::::

:::: {.column width="50%"}
- Some books use a special notation for the initial node, such as having an open circle rather than a closed circle.
- Bonanno doesn't, but it's clear in context what the initial node is.
::::

:::

## {.plain}

::: {.columns}

:::: {.column width="45%"}
![Example from Bonanno](images/3_1a.png){height=80%}
::::

:::: {.column width="50%"}

- As he goes on to note, this isn't really a tree yet.
- It describes the physical outcomes of the game at each terminal node, but not the **payoffs**.

::::

:::

## {.plain}

::: {.columns}

:::: {.column width="45%"}
![Example from Bonanno](images/3_1a.png){height=80%}
::::

:::: {.column width="50%"}
There is a natural function from outcomes to payoffs - more money equals more utility - but it is not a compulsory interpretation.
::::

:::

## Future Additions

> - Moves by Nature
> - Moves under uncertainty

# Backward Induction

## Class of Games We're Discussing

> - Two-player
> - Turn-taking
> - Finite
> - No hidden facts
> - No randomness
> - We'll start with zero-sum games, though drop this later.

## Five

- There are two players, who we'll call A and B.
- First A moves, then B, then finally A moves again. 
- Each move involves announcing a number, 1 or 2. 
- A wins if after the three moves, the numbers announced sum to 5. 
- B wins otherwise. 

## Five

Question: How should you play this game?

## Game Tree for Five {.fragile}
```{r engine="tikz"}
#| fig-format: png
#| echo: false


\usetikzlibrary{calc}

\begin{tikzpicture}
  \tikzset{
    % Three node styles for game trees: solid and hollow and square
      solid node/.style={circle,draw,inner sep=1.5,fill=black},
      hollow node/.style={circle,draw,inner sep=1.5},
      square node/.style={rectangle,draw, inner sep = 1, fill = black}
      }

  % Specify spacing for each level of the tree
  \tikzstyle{level 1}=[level distance=15mm,sibling distance=40mm]
  \tikzstyle{level 2}=[level distance=15mm,sibling distance=20mm]
  \tikzstyle{level 3}=[level distance=15mm,sibling distance=10mm]

  \node[hollow node,label=above:{A}]{}
    child { node [solid node,label=left:{B}] {}
      child { node [solid node,label=left:{A}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$L$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[left]{1}
        }
      child { node [solid node,label=right:{A}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[right]{2}
        }        
      edge from parent
        node[left]{1}
    }
    child { node [solid node,label=right:{B}] {}
      child { node [solid node,label=left:{A}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[left]{1}
        }
      child { node [solid node,label=right:{A}] {}
        child { node [] {$W$}
            edge from parent
            node[left]{1}}
        child { node [] {$L$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[right]{2}
        }        
      edge from parent
        node[right]{2}
    }
    
    ;
    \end{tikzpicture}
```


$W$ means that A wins, and $L$ means that B wins.

## Solving These Games

- Work backwards.
- First, find points where a player has a choice between two terminal nodes.
- Assume that they will make the higher value for them choice.
- Mark that choice, e.g., by doubling the line (as the textbook does).
- If there are ties, mark both of the lines. (This gets more complicated once we leave zero-sum games.)

## Solving These Games

- Assign the value they choose to the choice node.
- So just the game assigns values to terminal nodes, we'll now assign value to choice nodes.
- In **Five**, we'll assign the value $W$ to the bottom right node.

## Five (after one step)

```{r engine="tikz"}
#| fig-format: png
#| echo: false


\usetikzlibrary{calc}

\begin{tikzpicture}
  \tikzset{
    % Three node styles for game trees: solid and hollow and square
      solid node/.style={circle,draw,inner sep=1.5,fill=black},
      hollow node/.style={circle,draw,inner sep=1.5},
      square node/.style={rectangle,draw, inner sep = 1, fill = black}
      }

  % Specify spacing for each level of the tree
  \tikzstyle{level 1}=[level distance=15mm,sibling distance=40mm]
  \tikzstyle{level 2}=[level distance=15mm,sibling distance=20mm]
  \tikzstyle{level 3}=[level distance=15mm,sibling distance=10mm]

  \node[hollow node,label=above:{A}]{}
    child { node [solid node,label=left:{B}] {}
      child { node [solid node,label=left:{A}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$L$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[left]{1}
        }
      child { node [solid node,label=right:{A}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[right]{2}
        }        
      edge from parent
        node[left]{1}
    }
    child { node [solid node,label=right:{B}] {}
      child { node [solid node,label=left:{A}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[left]{1}
        }
      child { node [solid node,label=right:{$W$}] {}
        child { node [] {$W$}
            edge from parent [double]
            node[left]{1}}
        child { node [] {$L$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[right]{2}
        }        
      edge from parent
        node[right]{2}
    }
    
    ;
    \end{tikzpicture}
```

## Five (after first level)

On the next slide I'll do the same thing for the other three nodes where A ends the game.

- Note that for one of them, I'll double **two** lines, because we can't figure out just by backward induction reasoning what will happen.

---

```{r engine="tikz"}
#| fig-format: png
#| echo: false


\usetikzlibrary{calc}

\begin{tikzpicture}
  \tikzset{
    % Three node styles for game trees: solid and hollow and square
      solid node/.style={circle,draw,inner sep=1.5,fill=black},
      hollow node/.style={circle,draw,inner sep=1.5},
      square node/.style={rectangle,draw, inner sep = 1, fill = black}
      }

  % Specify spacing for each level of the tree
  \tikzstyle{level 1}=[level distance=15mm,sibling distance=40mm]
  \tikzstyle{level 2}=[level distance=15mm,sibling distance=20mm]
  \tikzstyle{level 3}=[level distance=15mm,sibling distance=10mm]

  \node[hollow node,label=above:{A}]{}
    child { node [solid node,label=left:{B}] {}
      child { node [solid node,label=left:{$L$}] {}
        child { node [] {$L$}
            edge from parent [double]
            node[left]{1}}
        child { node [] {$L$}
            edge from parent [double]
            node[right]{2}}
        edge from parent
            node[left]{1}
        }
      child { node [solid node,label=right:{$W$}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent [double]
            node[right]{2}}
        edge from parent
            node[right]{2}
        }        
      edge from parent
        node[left]{1}
    }
    child { node [solid node,label=right:{B}] {}
      child { node [solid node,label=left:{$W$}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent [double]
            node[right]{2}}
        edge from parent
            node[left]{1}
        }
      child { node [solid node,label=right:{$W$}] {}
        child { node [] {$W$}
            edge from parent [double]
            node[left]{1}}
        child { node [] {$L$}
            edge from parent
            node[right]{2}}
        edge from parent
            node[right]{2}
        }        
      edge from parent
        node[right]{2}
    }
    
    ;
    \end{tikzpicture}
```

## Next Steps Back

- Now we do the same thing for B.
- We act as if B is choosing between terminal nodes.
- It is as if A doesn't have a choice - they will just make the choice that is best for them (i.e., worst for B).
- So B knows what the outcome of each choice will be.
- Remember, B prefers $L$ to $W$, because $L$ means that A loses and so B wins.

---

```{r engine="tikz"}
#| fig-format: png
#| echo: false


\usetikzlibrary{calc}

\begin{tikzpicture}
  \tikzset{
    % Three node styles for game trees: solid and hollow and square
      solid node/.style={circle,draw,inner sep=1.5,fill=black},
      hollow node/.style={circle,draw,inner sep=1.5},
      square node/.style={rectangle,draw, inner sep = 1, fill = black}
      }

  % Specify spacing for each level of the tree
  \tikzstyle{level 1}=[level distance=15mm,sibling distance=40mm]
  \tikzstyle{level 2}=[level distance=15mm,sibling distance=20mm]
  \tikzstyle{level 3}=[level distance=15mm,sibling distance=10mm]

  \node[hollow node,label=above:{A}]{}
    child { node [solid node,label=left:{$L$}] {}
      child { node [solid node,label=left:{$L$}] {}
        child { node [] {$L$}
            edge from parent [double]
            node[left]{1}}
        child { node [] {$L$}
            edge from parent [double]
            node[right]{2}}
        edge from parent [double]
            node[left]{1}
        }
      child { node [solid node,label=right:{$W$}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent [double]
            node[right]{2}}
        edge from parent
            node[right]{2}
        }        
      edge from parent
        node[left]{1}
    }
    child { node [solid node,label=right:{$W$}] {}
      child { node [solid node,label=left:{$W$}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent [double]
            node[right]{2}}
        edge from parent [double]
            node[left]{1}
        }
      child { node [solid node,label=right:{$W$}] {}
        child { node [] {$W$}
            edge from parent [double]
            node[left]{1}}
        child { node [] {$L$}
            edge from parent
            node[right]{2}}
        edge from parent [double]
            node[right]{2}
        }        
      edge from parent
        node[right]{2}
    }
    
    ;
    \end{tikzpicture}
```

## Five (After Two Rounds)

- So we act as if getting to the left hand node means B wins, and getting to the right hand node means A wins.
- And now we just have to make the choice for the initial node, using this fact.

## Five (Full Graph)

```{r engine="tikz"}
#| fig-format: png
#| echo: false


\usetikzlibrary{calc}

\begin{tikzpicture}
  \tikzset{
    % Three node styles for game trees: solid and hollow and square
      solid node/.style={circle,draw,inner sep=1.5,fill=black},
      hollow node/.style={circle,draw,inner sep=1.5},
      square node/.style={rectangle,draw, inner sep = 1, fill = black}
      }

  % Specify spacing for each level of the tree
  \tikzstyle{level 1}=[level distance=15mm,sibling distance=40mm]
  \tikzstyle{level 2}=[level distance=15mm,sibling distance=20mm]
  \tikzstyle{level 3}=[level distance=15mm,sibling distance=10mm]

  \node[hollow node,label=above:{$W$}]{}
    child { node [solid node,label=left:{$L$}] {}
      child { node [solid node,label=left:{$L$}] {}
        child { node [] {$L$}
            edge from parent [double]
            node[left]{1}}
        child { node [] {$L$}
            edge from parent [double]
            node[right]{2}}
        edge from parent [double]
            node[left]{1}
        }
      child { node [solid node,label=right:{$W$}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent [double]
            node[right]{2}}
        edge from parent
            node[right]{2}
        }        
      edge from parent
        node[left]{1}
    }
    child { node [solid node,label=right:{$W$}] {}
      child { node [solid node,label=left:{$W$}] {}
        child { node [] {$L$}
            edge from parent
            node[left]{1}}
        child { node [] {$W$}
            edge from parent [double]
            node[right]{2}}
        edge from parent [double]
            node[left]{1}
        }
      child { node [solid node,label=right:{$W$}] {}
        child { node [] {$W$}
            edge from parent [double]
            node[left]{1}}
        child { node [] {$L$}
            edge from parent
            node[right]{2}}
        edge from parent [double]
            node[right]{2}
        }        
      edge from parent [double]
        node[right]{2}
    }
    
    ;
    \end{tikzpicture}
```

## Five - Full Analysis

- The equilibrium state of the game is that A wins.
- A plays 2 first.
- Then B can play anything they line.
- But whatever they do, A will win, by playing the opposite number.

## Backwards Induction

- This process is called backwards induction.
- We start at the possible ends of the game.
- At each step, we assume that each player makes the best decision they can, on the assumption that later players will do the same thing.

# Chain Store Paradox

## Chain Store Paradox

The Wikipedia page on this isn't bad, and the original article is somewhat accessible.

- [The Chain Store Paradox](https://link.springer.com/article/10.1007/BF00131770), by Reinhard Selten, _Theory and Decision_ volume 9, 1978.

## Chain Store Paradox

- Imagine in 20 college towns, Starbucks is the only coffee shop in town.
- In each of the towns, some local business people are thinking of starting a new coffee shop.
- Each of them will soon face a critical decision, whether to go ahead with the shop or give up because it's too hard.

## Payouts

In each town, there are four options:

- The local person can enter (E) or stay out (S).
- If they enter, Starbucks can do nothing (N) or cut prices (C). (Note this happens second.)

Here is the payoff table per town.

|    |   E   |   S   |
|:--:|:-----:|:-----:|
| N  |   2,2 |  1,5  |
| C  |  0,0  |  1,5  |

## Payouts

|    |   E   |   S   |
|:--:|:-----:|:-----:|
| N  |   2,2 |  1,5  |
| C  |  0,0  |  1,5  |

In each town, the only equilibrium of the game is that the local enters, and Starbucks does nothing.

## Chain Store

What about the following reasoning for Starbucks?

- In the first town, if local enters, we'll get 0 rather than 2 by starting a price war.
- That's a cost, but it's nothing compared to the deterrence effect.
- Sending a message to the other 19 that they're better off staying out will be worth losing some money in town 1.

## Threat

|    |   E   |   S   |
|:--:|:-----:|:-----:|
| N  |   2,2 |  1,5  |
| C  |  0,0  |  1,5  |

Note that for subsequent towns, the local has a choice between getting 1, if they stay out, or 0, if they enter, assuming Starbucks will launch a price war.

## Threats

This might not be particularly *nice* of Starbucks, and maybe in some places it would even be illegal. (Though really, who is going to start a lawsuit against Starbucks cutting prices?)

But this sure looks like sensible reasoning on Starbucks's part.

Take a small loss now to preserve the value of monopoly privileges in the future.

## Backward Induction

The problem is that there's this argument that it shouldn't work.

- In town 20, there is no deterrence benefit from cutting prices.
- So Starbucks won't cut prices there, and the fact that they did in the past won't deter the locals in town 20.

## Backward Induction

Now think about the locals in town 19. Should they fear that Starbucks will launch a price war to deter future owners?

- No; it would only deter the locals in town 20, and we just showed they shouldn't ever be deterred.
- So the locals in town 19 shouldn't be deterred.

. . .

And that holds in 18, in 17, and all the way back to the start.

## What Went Wrong

Backward induction reasoning requires a *very* strong rationality assumption.

- It requires not just that everyone is rational, but that everyone knows everyone is rational, everyone knows that everyone knows that everyone is rational, and so on.
- And this is not what we find in the real world.

## An Experiment

- You'll play the following game. I'm hoping you'll play it three times with three different people, though at the mercy of the tech a little here.
- The game is called **Centipede**.

![Centipede tree from Wikipedia](centipede.png)

---

- At the start of the game there is $0.20 in a pot.
- At each round, a player can end or continue. (This game is not symmetric; someone goes first.)
- If the game ends, the pot is divided **unevenly**. The person who ended the game gets $0.20 more.
- So if it ends with \$1 in the pot, the ender gets \$0.60, and the other player gets \$0.40.
- If the game does not end, $0.20 gets added to the pot.
- Once the pot reaches \$2, the game ends, and player 2 gets \$1.10, while player 1 gets \$0.90.

---

| Ending Round | Ending Player |   P1    |   P2   |
|:------------:|:-------------:|:-------:|:------:|
|      1       |       1       |  $0.20  |   0    |
|      2       |       2       |  $0.10  |  $0.30 |
|      3       |       1       |  $0.40  |  $0.20 |
|      4       |       2       |  $0.30  |  $0.50 |
|      5       |       1       |  $0.60  |  $0.40 |
|      6       |       2       |  $0.50  |  $0.70 |
|      7       |       1       |  $0.80  |  $0.60 |
|      8       |       2       |  $0.70  |  $0.90 |
|      9       |       1       |  $1.00  |  $0.80 |
|     10       |  2 (force)    |  $0.90  |  $1.10 |

## Theory

- The backward induction solution to the game is that player 1 ends on the first move.
- At the second last move, player 1 can end and get \$1, or continue and get \$0.90.
- At the third last move, player 2 can end and get \$0.90, or continue, and, if player 1 ends the next move, get \$0.80.
- And so on, until player 1 ends on the very first move.
- Let's see if that happens in practice.

## Experiment

- https://veconlab.econ.virginia.edu/login.php
- Experiment name: **pbw4**
- This is last slide; but hopefully we'll have time to talk about what happened.
